ウェブアニメーション風景

jQueryの - 2006年のウェブの主要なアニメーションツール、始まった開発を兼ねたのに対し、速度は2014年に建てられました。このように、それはゼロから最新のパフォーマンスのベスト·プラクティスが組み込まれています。

要するに、速度は上にアニメーションレイヤ軽量CSSの操作ライブラリである。これは、JavaScriptやCSSのではない遷移によって完全に電力供給だ。それはjQueryの$と同じAPIを公開しています。$からの移行を容易にするために（）アニメーション化します。アニメーション化（）$に。速度（）。

速度、DOMのアニメーションの風景の前には、主に、jQueryの、トランジット（ゴー·トゥライブラリJavaScriptでCSSの遷移を制御するための）、およびGSAP（最初のパフォーマンスのJavaScriptのアニメーションライブラリ）で構成されていた。

ここでは、それらのライブラリの欠点は以下のとおりです。

jQueryのネイティブ$。アニメーション化（）はjQueryのUIとペアに設計上の特徴でさえ、UIのアニメーションが遅いと比較的軽い。
トランジットは、jQueryのよりもかなり高速ですが、機能のさらに軽くですが、時々によりJavaScriptでCSSの遷移をシムのその性質にバグがあり、IE8とIE9の（巨大なグローバルブラウザのシェアを持ち続けているサポートしていません。
GSAPは驚異的なパワーを持つ本格的なアニメーション·プラットフォームです。その特徴はほぼ無限です。それは、DOMからWebGLのには何をアニメーション化します。 （速度は、対照的に、もっぱら大幅なUIのアニメーションのパフォーマンスとワークフローを改善するための軽量なツールであることに焦点を当てています。）GSAPは、企業の様々なタイプのライセンス料が必要なのに対し、速度を自由にオープンソースの超寛容なMITライセンスを使用することです。
速度は劇的にストレスのすべてのレベルでjQueryを凌駕し、トランジットはストレスのメディアのレベルで始まる。 GSAPは、Velocityと同じように実行します。頭に頭のUIパフォーマンス比較のために、速度のマニュアルを参照してください。

タイマーの最適化

私たちは、ジューシーなパフォーマンス詳細に飛び込む準備ができました。どのようにアニメーションエンジンの高速を作るのですか？それはミクロの最適化ですか？いや。

速度ゼロのマイクロ最適化があります。これは私が降圧することを確認しました傾向である。スタックオーバーフローは、善意の開発者は、JavaScriptベースの実装では、最もパフォーマンスであるかを決定するために使用するjsPerf.comの比較に満ちている。しかし、開発者は多くの場合、彼らのコンテキストを考慮することなく、これらの顔の値の比較の餌食になる。 1の実装はすでに、毎秒数百万の操作を達することができる場合は、その代替実装がどのようにはるかに高速無関係です。 JavaScriptコードは、おそらく秒あたりの操作数百万の規模で実行することはありません。

DOMのパフォーマンスの本当のボトルネックは、主に、タイマーの作成およびDOM操作です。

それでは、タイマーの作成を分析することから始めましょう。ときのsetInterval（）のsetTimeout（）タイマーが作成され、requestAnimationFrame（）が使用されている。タイマーの作成と2つのパフォーマンスの問題があります。1）一度で焼成し、あまりにも多くのタイマーは、それらを維持し、かつ2）不適切なアニメーションがドロップされたフレームに結果を開始する時刻をマークするブラウザのオーバーヘッドのためにフレームレートを低減します。

第一の問題に対する速度のソリューションは、一度にすべてのアクティブな速度アニメーションを通じて、そのサイクル単一のグローバルチックループを維持している。個々のタイマーは各ベロシティ·アニメーションのために作成されていません。要するに、速度は中断にわたるスケジューリングの優先順位を決定します。

ループの経過時間を追跡することができるように、アニメーションが開始された時刻をマークする第二の問題は、最初のアニメーションティック自体の内部で直接開始時間を設定することによって解決される。

対照的に、開発者は、典型的には、アニメーションがトリガされた時点で、そのアニメーションの開始時間を設定する。しかしながら、ユーザが、たとえば、UIアニメーションをトリガーするボタンをクリックした時間、得られたアニメーションループが実際に開始される点と、サードパーティの因子（関連のJavaScriptロジック、追加のUI相互作用、システム全体の負荷、など）の遅延が発生する可能性があります。アニメーションループは、最終的に（例えば、〜16-85ms以降）を起動しない場合にはその後、ほとんどのアニメーションループが実装されている方法は、時間のずれを補うために削除されている先行フレームの塊になります。

アニメーションがトリガされたときに実際にはない第アニメーションループティック内部に開始時間を設定し、速度の結果、アニメーションがトリガされ、その開始点を越えて〜16-85msを開始する可能性を有することである。この遅延は、しかし、実質的に知覚できない、あなたがない限り、最終的には無関係である、例えば、多くの場合、時間に正確な衝突検出が必要なゲームを作成する。

要約すると、UIのアニメーションで、滑らかさは常に時間精度よりも優先されるべきである。

DOM操作を最小限に抑える

DOM操作の最小化 - タイマの最適化は、単に速度の基礎となる、実際のパフォーマンスの最適化への足がかりである。ベロシティの後ろコア性能プリンシパルを使用すると、提供することができ、フレームレート（脳が毎秒非常に多くのフレームのみ知覚することができる）には上限がありますが、あなたはDOM操作を回避する方法を巧みに上限はありません、です。

DOMは、当然のことながら、Webページ上のHTMLの基礎となる階層的な表現です。当然のことながら、DOM操作、設定となって構成されています。あなたは要素のCSSプロパティの値を変更するときは、（更新）DOMを設定している。あなたは、要素のCSSプロパティの現在の値のためのDOMを照会するとき、逆に、あなたは（クエリ）を取得している。これらのDOMアクションは、パフォーマンス上のオーバーヘッドが発生します。 DOMを設定した後、ブラウザは変更の影響を計算することがあります。あなたは1要素の幅を変更すると結局、その親、兄弟、子要素の幅が変化をもたらす連鎖反応を引き起こすことができます。

DOMを交互に起因するフレームレート低下のこの現象は、設定し、として知られているれます "レイアウトスラッシング」。

ブラウザは、すぐに、DOMレイアウト再計算を実行するために最適化されていますが、アニメーションループが同時に動作しているときに、ミリ秒ごとに貴重であり、DOM操作は、（複数のミリ秒の範囲で、ブラウザのオーバーヘッドをトリガする最も簡単な方法である分数内で最もJavaScriptの操作の完全なのに対し、ミリ秒）。文脈化する方法を時間に敏感なアニメーションループは、毎秒60フレームアニメーションループ内のすべてのダニが16msの内に完了しなければなりません（目がバター、滑らかな動きを感知する速度）（1s/60 = 16.666ms）を達成するためには、 。

速度は全体でレイアウトスラッシング、およびDOM操作を最小限にするために偉大な長さになります。

まず、速度の唯一の開発者として、私は、DOMを操作するコードのすべての問題のある行をハイライトするベロシティのソースを通じてコメントを配置するために時間がかかる。簡単に言うと、私は* /どこでも適切な/ *取得します* /と/ *セットを振りかける。この練習に付着していることは私はすぐに新しい機能やバグ修正がレイアウトスラッシングを導入しないことを確実にするために自分のコードを眼球することができます。私は、コードパスをたどると/ * / / * SET * /に続いて取得した場合を参照してください。もしそうなら、私はどちらかのバッチセットにパスを手直しし、（スラッシングの総発生を最小限に抑えるために）一緒に取得するか、私は完全に機能を実装することは避けてください。

DOMは、すべてのアニメーションの開始時に再照会する必要がないように、第2、速度はキャッシュされた値、可能な限りで動作します。複数のアニメーションを一緒に連鎖されている場合など、速度を検知し、その後のコールの開始値として前のVelocityコールのアニメーション終了値を再利用します。これは古くなった値で動作するすべてのコストで回避する必要があるため、デリケートなプロセスであり、それ以外のアニメーションが破壊する恐れがあります。ベロシティ·アドレスごとに速度が開始したアニメーションのコールを通報することで、この不確実性、それはチェーンの前に呼び出し、速度（例えばjQueryの$。キュー（）または$で開始されなかったことを検知した場合、続いて値のキャッシュを回避することができる。フェード（）関数があったベロシティー呼び出しの間）を注入。

ベロシティが採用して第三の、そして最後の、主要なDOM最小化技術は、単位変換率への「真空」アプローチです。単位変換ロジックは、一パーセントの単位画素に関するものであるかを決定するコードである。これは、アニメーションエンジンは、その値がピクセル単位であるもの、「25パーセント」を決定しなければならないため、例えば、素子の幅をアニメートする際に必要となるように、増分演算は、同じユニット型の二つの値を用いて行うことができる。なぜ特定のピクセル？照会に関係なく、どのようなユニット型のがプロパティを設定するために使用されたときにブラウザがピクセル単位でのCSSプロパティの値を返すため。

単位変換処理が一時的に次のDOMクエリは、その要素の寸法について返すもの算出次いで1％対象要素の幅と高さを設定することを伴う。ピクセルになります返される値は、1％と画素の間の比を提供します。

速度は、本機の変換処理中に3つの重要な最適化が行われます。第一に、それは彼らが同じ比率（すなわち、それらが同じ親要素と同じCSS位置の値を持っている）を共有するかどうかを判断するテストをパス要素間で単位変換比をキャッシュします。要素のセットを一度にアニメーション化されているとき、これは重要である。

それが必要ないですときに、第2、速度は全体で単位変換をスキップします。プロパティの開始値が0である場合、例えば、ゼロ各ユニットA型変換なしにゼロである必要がある。

第三に、速度を一意DOMツリーの変更の上レイアウトスラッシングのために付き合えない。前者の技術は、DOMを交互に望ましくない量を取得し、一時的にそれは、ディメンションの計算（例えば、ボックスサイズ、オーバーフロー）に影響を与えることができるCSSプロパティを剥奪の仮想CSSプロパティ「真空」のアニメーション要素を入れることでセットが生成されます。一時的な値の設定および取得に続いて不動産のストリッピングは、さらにその初期値に要素をリセットすることで、その後、レイアウトスラッシングのいくつかのラウンドを必要とする。

しかし、私は速度の開発中に持っていた発見は、レイアウトスラッシングが今まで使用されていた手法よりもパフォーマンスの高いということです。、アニメーション要素をクローニングすることにより、DOMツリーを根こそぎ元の横のクローンを挿入、上の単位変換を行うクローンは、その後、完全にクローンを削除する。これはCSS真空を作成する非自明なプロセスを回避するが、それは（要素の挿入および除去を介して、その階層に影響を与えることによって）、DOMツリーの再構築をもたらすので、この方法は、最終的に交互超えるブラウザのオーバーヘッドを引き起こす、望ましいCSSプロパティの値はありません。 （私は、ブラウザやデバイス間で、これらの結果を確認するためにjsPerf.comを使用し、そのメンテナが教えてくれますように、これはjsPerfが途方もなく強力な - とすると、多くの環境間で真のボトルネックの状況を比較する必要になるところである。）